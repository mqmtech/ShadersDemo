// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelMoveParticles
#pragma kernel KernelResizeVertices
#pragma kernel KernelMeltVertices

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Particle
{
	float3 position;
	float3 velocity;
	float3 size;
};

float _Width;
float _Height;

RWStructuredBuffer<Particle> _ParticlesBuffer;
RWStructuredBuffer<float3> _Vertices;

float _DeltaTime;
float _Time;

//---- Helpers
int getIdxFromId(uint3 id)
{
	return id.x + id.y * _Width;
}

int getIdxFromIdV(uint3 idv)
{
	return idv.x + idv.y * _Width*4*6;
}

//---- Kernels
[numthreads(16,16,1)]
void KernelMoveParticles (uint3 id : SV_DispatchThreadID)
{
	uint idx = getIdxFromId(id);
	
	_ParticlesBuffer[idx].position += _ParticlesBuffer[idx].velocity * _DeltaTime * sign(sin(_Time * 0.2));
	_ParticlesBuffer[idx].position.y = sin(_ParticlesBuffer[idx].position.x);
}

[numthreads(16,16,1)]
void KernelResizeVertices (uint3 id : SV_DispatchThreadID)
{
	uint idx = getIdxFromId(id);

	_ParticlesBuffer[idx].size.y += 0.5 * sin(length(_ParticlesBuffer[idx].position * 10.0) + _Time);
}

[numthreads(144,6,1)]
void KernelMeltVertices (uint3 idv : SV_DispatchThreadID)
{
	uint xInstance = floor(idv.x/(4*6));
	uint3 id = uint3(xInstance, idv.y, idv.z);
	uint idx = getIdxFromId(id);
	
	uint vidx = getIdxFromIdV(idv);
	uint v0Idx = (4*6) * idx;
	uint localVIdx = vidx - v0Idx;
	if(localVIdx >= 4 && localVIdx <= 5)
	{
		_Vertices[vidx] += normalize(float3(1, 0, 0)) * (0.5+0.5*sin(_Time)) * 0.15;
	}
	else if(localVIdx >= 6 && localVIdx <= 7)
	{
		_Vertices[vidx] += normalize(float3(-1, 0, 0)) * (0.5+0.5*sin(_Time)) * 0.15;
	}
}
